Modeling scope:
    A watershed with a single basin outlet.
    Semi-distributed model (not grid).


About agents:
We have three agent APIs:
(1) InsituAgentTypes: Directly divert/add water from subbasin before routing.
(2) RiverDivAgents: Add water to outlets before routing or divert water from
    outlets after routing.
(3) DamAgents : Complete redefine instream water after upstream routing.
(4) ConveyAgent : Directly convey water from one node to another.

Here we define an agent as an actor which associates with a unique name and 
setting dict in the model.yaml. Each agent belong to one agent type and one 
decision-making class (DMClass). An agent type is a user-defined class followed
by a basic structure defined below:

Class AgType():
    def __init__(self, Name, Config, StartDate, DataLength):
        # Initialization
        pass
    def act(self, Q, AgentDict, node, CurrentDate, t, DM):
        # Action when agent is called at every HydroCNHS simulation time step 
        # (day). This is not the decision-making (DM) step. When to exercute DM
        # will need to be explicilty defined here. 
        return self.Q

As mentioned above each agent will be assigned with a DMClass, which has 
its structure defined below:

class DMClass():
    def __init__(self, StartDate, DataLength, ABM):
        # Initialization
        pass
    def __call__(self, Q, t, CurrentDate, ag, Output, AssignValue = False):
        # Double-check whether to run DMFunc, especially for group agents,
        # which they make their desicions together. Therfore, their DMFunc only
        # need to be exercuted once in a simulation (decision) time step.
        return Output
    def DMFunc(self):
        # Main decision-making function.
        pass

The second layer of the ABM is so-called agent group. Agents belong to a group
will be exercute together. Namely, the unique group name will be use as a call
name in the HydroCNHS. Therefore, the agent group agent type should contain a 
for loop to go over each within-group agent. The group infomation is defined in
Inputs under ABM settings.

In some cases, we need to have a jointly operated reservoirs, which means we 
need those reservoirs' upstream routing to be done. Namely, we need to ensure 
the routing outlets' simulation order is correct. Therefore, the grouped dam
-type agent type will be automatically detected and reorder the sorted 
simulation sequence.

Naming system==================================================================
Modules: module_name
Classes: ClassName
Functions: verb_XXX_XXX()
Internal variables: internal_variable
Arguments: argument_of_the_function
Name in yaml: ItemName

Package (HydroCNHS) structure==================================================
                            Rename  Check    Doc    Test_func
__init__.py                 OK      OK
hydrocnhs.py                OK      OK
routing.py                  OK      OK
util.py                     OK      OK
indicators.py               OK      OK
visual.py                   ~OK
model_builder.py
land_surface_model          OK
    __init__.py             OK
    gwlf.py                 OK      OK
    abcd.py                 OK
    hymod.py                OK      -
    pet_hamon.py            OK      OK
calibration                 OK      OK
    __init__.py             OK      OK
    convertor.py            OK      OK
    ga_deap.py              OK      OK
config
    Config_default.yaml
    Config_logging.yaml
    Config.yaml
==================================================
HydroCNHS
Example
Tests
Docs
setup.py
MANIFEST.in
README.md

YAML structure=================================================================
Path: 
    WD: str
    Modules: str
WaterSystem:
    StartDate: str
    EndDate: str            # Optional if given DataLength
    NumSubbasins: int
    NumGauges: int
    NumAgents: int          ### Redundent
    Outlets: []
    GaugedOutlets: []       ### Use only for auto-calibration and auto-plot.
    DataLength: int         # Optional if given EndDate
    GroupNodes = [[], []]   # Optional
LSM:
  Model: str
  subbasinName:
    Inputs: {}
    Pars: {}

Routing:
  Model: str
  ToOutlet:
    FromOutlet1:
        Inputs: {FlowLength: , InstreamControl: }
        Pars: {}
    FromOutlet2:
        Inputs: {}
        Pars: {}

ABM:
  Inputs:
    InsituAgentTypes: []
    RiverDivAgentTypes: []
    DamAgentTypes: []
    ConveyAgentTypes: []    
    DMClasses: []
    Modules: []
    AgGroup:
      AgentTypeForAgGroup:
        GroupName: [Roza, Wapato, Sunnyside]
  AgentType:
    AgentName:
        Attributes:
        Inputs:
            Piority: 0
            Links: {FromOutletName: -1, ToOutletName: 1}
            # We have a special case for return flow.
        Pars:


To do==========================================================================
Need to rethink the DMClass logic or explanation
Test run
Function documentation
Maybe initiate data collector
    https://github.com/projectmesa/mesa/blob/main/mesa/datacollection.py
test function
User guide
Technical report
default_config()
plot_equifinal()
get_equifinal_models()
model_builder
ga_deap to let user be able to change deap setup.

Done list======================================================================
Test sim sequence: Make sure your back tracking is workable for cross sub basin
                   but same human group.
Test DEAP
Turn to three apis
Rename YAML => Attributes
Correct all naming issues and code style.
Move load module ahead of LSM simulation