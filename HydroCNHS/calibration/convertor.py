# Convertor module.
# by Chung-Yi Lin @ Lehigh University (philip928lin@gmail.com) 
# Last update at 2021/12/22.
import ast
import pandas as pd
import numpy as np

class Convertor(object):
    def __init__(self):
        """Convertor helps user to convert multiple parameter dataframes (can
        contain nan values) into an 1D array (parameters for calibration,
        automatically exclude nan values) that can be used for GA calibration.
        And the formatter created by Convertor can be used to convert 1D array
        back to a list of original dataframes. The inputs dictionary for GA can also be
        generated by Convertor. Besides, we provide option for defining
        fixed parameters, which those parameters will not enter the
        calibration process (exclude from the 1D array).
        Note: Dataframe index is parameter names.
        """
        pass
        
    def gen_formatter(self, df_list, fixed_par_list=None):
        """Generate formatter for given list of dataframe objects. This is 
        already included in gen_cali_inputs().

        Parameters
        ----------
        df_list : list
            A list of parameter dataframes. Dataframe index is parameter names.
        fixed_par_list : list, optional
            A list contains a list of tuples of fixed parameter location. For
            example, we want to fix par1 of outlet1 & 2 and all par2 in 
            dataframe 1 and not to fix df2. We can input the following list,
            [[(["par1"], ["outlet1", "outlet2"]), (["par2"], [":"])], []]. 
            fixed_par_list is by default None. The number of lists in the list
            is corresponding to the number of dataframes.
            
        Returns
        -------
        dict
            formatter.
        """
        
        for i in range(len(df_list)):
            # Convert index and column into String, since tuple is not directly
            # callable.
            parsed_index = [str(item) for item in df_list[i].index]
            parsed_col = [str(item) for item in df_list[i].columns]
            df_list[i].index = parsed_index
            df_list[i].columns = parsed_col
            
        formatter = {"num_of_df": None,
                    "shape_list": [],
                    "col_name_list": [],
                    "index_name_list": [],
                    "index": [0],
                    "none_index": None,
                    "fixed_par_list": None,
                    "fixed_par_val_list": []}
        if fixed_par_list is not None:
                formatter["fixed_par_list"] = fixed_par_list
        
        formatter["num_of_df"] = len(df_list)
        var_array = []        
        for i, df in enumerate(df_list):
            formatter["shape_list"].append(df.shape)
            formatter["col_name_list"].append(df.columns.values)
            formatter["index_name_list"].append(df.index.values)
            # Store fixed par and replace their values with None in df.
            
            if fixed_par_list is not None:
                fixed_par_val_list = []
                for tup in fixed_par_list[i]:
                    if tup[1] == ":":       # For all columns.
                        tup = (tup[0], list(df))
                    if tup[0] == ":":       # For all index.
                        tup = (list(df.index), tup[1])
                    value = df.loc[tup[0], tup[1]].to_numpy()
                    fixed_par_val_list.append(value)
                    df.loc[tup[0], tup[1]] = None
                formatter["fixed_par_val_list"].append(fixed_par_val_list)
            # Convert to 1d array
            # Ensure when None occur in df, it will be replace by np.nan.
            df = df.replace({None: np.nan})
            # [Row1, Row2, .....
            var_array = var_array + list(df.to_numpy().flatten("C"))
            # Add index (where it ends in the 1D array)
            formatter["index"].append(len(var_array))
            
        var_array = np.array(var_array) # list to array
        formatter["none_index"] = list(
            np.argwhere(np.isnan(var_array)).flatten()
            )   # Find index for np.nan values.
        self.formatter = formatter
        return formatter
    
    
    def gen_cali_inputs(self, wd, df_list, par_bound_df_list,
                        fixed_par_list=None):
        """Generate inputs dictionary required for calibration.

        Parameters
        ----------
        wd : str
            Working directory.
        df_list : list
            A list of parameter dataframes. Dataframe index is parameter names.
        par_bound_df_list : list
            A list of parameter bound dataframes.
        fixed_par_list : list, optional
            A list contains a list of tuples of fixed parameter location like
            [(["CN2"], ["outlet1", "outlet2"]), (["b"], ["outlet1"])], by
            default None. The number of tuples in the list is corresponding to
            the number of dataframes.
            
        Returns
        -------
        dict
            Input for calibration.
        """
        # Parse value from str to list or others.
        def parse(i):
            try:
                val = ast.literal_eval(i)
                return val
            except:
                return i           
        
        # Compute formatter
        # We use par_bound_df_list to determine None.
        self.gen_formatter(df_list, fixed_par_list)
        formatter = self.formatter
        none_index = formatter["none_index"]
        par_name = []
        par_bound = []
        # Form a list of above infomation (1D)
        for i in range(len(df_list)):
            col_name_list_d = formatter["col_name_list"][i]
            index_name_list_d = formatter["index_name_list"][i]
            # Make sure index and column is callable and identical to df_list.
            par_bound_df_list[i].index = index_name_list_d
            par_bound_df_list[i].columns = col_name_list_d
                
            # Assignment starts here.    
            for par in index_name_list_d:
                for c in col_name_list_d:
                    par_name.append(str(par)+"|"+str(c))
                    par_bound.append(parse(par_bound_df_list[i].loc[par,c]))
        # Remove elements in None index from formatter. This includes fixed
        # pars and pars with None values. 
        def delete_multiple_element(list_object, indices):
            indices = sorted(indices, reverse=True)
            for idx in indices:
                if idx < len(list_object):
                    list_object.pop(idx)
        delete_multiple_element(par_name, none_index)
        delete_multiple_element(par_bound, none_index)
        inputs = {"wd": wd, "par_name": par_name, "par_bound": par_bound}
        self.inputs = inputs
        return inputs
    
    @staticmethod
    def to_1D_array(df_list, formatter):
        """Convert a list of dataframes to a 1D array.

        Parameters
        ----------
        df_list : list
            A list of parameter dataframes. Dataframe index is parameter names.
        formatter : dict
            Formatter, generated by gen_formatter or gen_cali_inputs. It is
            stored in attributes of the Convertor object.

        Returns
        -------
        array
            1D array.
        """
        var_array = []        
        for df in df_list:
            # Convert to 1d array
            var_array = var_array + list(df.to_numpy().flatten("C"))   
            
        def delete_multiple_element(list_object, indices):
            indices = sorted(indices, reverse=True)
            for idx in indices:
                if idx < len(list_object):
                    list_object.pop(idx)
        delete_multiple_element(var_array, formatter["none_index"])
        
        return np.array(var_array)
    
    @staticmethod
    def to_df_list(var_array, formatter):
        """Convert 1D array back to a list of dataframes.

        Parameters
        ----------
        var_array : array
            1D array.
        formatter : dict
            Formatter, generated by gen_formatter or gen_cali_inputs. It is
            stored in attributes of the Convertor object.

        Returns
        -------
        list
            A list of dataframes.
        """
        none_index = formatter["none_index"]
        index = formatter["index"]
        # Insert np.nan to var_array following none_index
        var_array = var_array.astype("float")
        for i in none_index:
            var_array = np.insert(var_array,i,np.nan)
            
        # Form df_list
        df_list = []
        for i in range(formatter["num_of_df"]):
            # 1d array to dataframe 
            df = np.reshape(var_array[index[i]: index[i+1]],
                            formatter["shape_list"][i], "C")
            df = pd.DataFrame(df)
            df.index = formatter["index_name_list"][i]
            df.columns = formatter["col_name_list"][i]
            # Add fixed values back
            if formatter["fixed_par_list"] is not None:
                for ii, tup in enumerate(formatter["fixed_par_list"][i]):
                    if tup[1] == ":":       # For all columns.
                        tup = (tup[0], list(df))
                    if tup[0] == ":":       # For all index.
                        tup = (list(df.index), tup[1])
                    aa = formatter["fixed_par_val_list"][i][ii]
                    df.loc[tup[0], tup[1]] = aa
            df_list.append(df)
            
        return df_list

#%%
### Example
# import numpy as np
# import pandas as pd
# import HydroCNHS
# import HydroCNHS.calibration as cali

# ### Prepare testing data.
# par_df1 = pd.DataFrame({"Subbasin1": [1000,1000,3], "Subbasin2": [4,5,6]},
#                       index=["a", "b", "c"])
# par_df2 = pd.DataFrame({"Agent1": [9,8,7], "Agent2": [6,5,None]},
#                       index=["Par1", "Par2", "Par3"])

# bound_df1 = pd.DataFrame({"Subbasin1": [[0,1000],[0,1000],[0,10]], "Subbasin2": [[0,10],[0,10],[0,10]]},
#                       index=["a", "b", "c"])
# bound_df2 = pd.DataFrame({"Agent1": [[0,10],[0,10],[0,10]], "Agent2": [[0,10],[0,10],None]},
#                       index=["Par1", "Par2", "Par3"])

# df_list = [par_df1, par_df2]
# par_bound_df_list = [bound_df1, bound_df2]


### Create a object called Converter.
# converter = cali.Convertor()

# ### Generate GA inputs with fixed a & b parameters for Subbasin1.
# fixed_par_list = [[(["a","b"], ["Subbasin1"])],[]]
# cali_inputs = converter.gen_cali_inputs(
#     "working directory", df_list, par_bound_df_list, fixed_par_list)
# ### Get formatter
# formatter = converter.formatter

# ### Show cali_inputs
# print(cali_inputs)
# r"""
# print(cali_inputs)
# {'wd': 'working directory', 
#  'par_name': ['a|Subbasin2', 'b|Subbasin2', 'c|Subbasin1', 'c|Subbasin2', 
#               'Par1|Agent1', 'Par1|Agent2', 'Par2|Agent1', 'Par2|Agent2', 
#               'Par3|Agent1'], 
#  'par_bound': [[0, 10], [0, 10], [0, 10], [0, 10], [0, 10], [0, 10], [0, 10], 
#                [0, 10], [0, 10]]}
# """

# ### to 1D array
# converter.to_1D_array(df_list, formatter)
# r"""
# # Out[31]: array([4., 5., 3., 6., 9., 6., 8., 5., 7.])
# # Note the order of the array corresponds to "par_name" in the cali_inputs.
# """

# ### to df_list
# var_array = np.array([5]*9)
# converter.to_df_list(var_array, formatter)
# r"""
# Out[46]: 
# [   Subbasin1  Subbasin2
#  a     1000.0        5.0
#  b     1000.0        5.0
#  c        5.0        5.0,
#        Agent1  Agent2
#  Par1     5.0     5.0
#  Par2     5.0     5.0
#  Par3     5.0     NaN]
# """